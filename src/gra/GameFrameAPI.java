
package gra;

import java.awt.*;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.*;

/**
 *
 * @author Komputer Domowy
 */
public class GameFrameAPI extends JFrame implements GameFrame {
    private Map<Color, JButton[]> houseFields = new HashMap<>(InitValue.COUNTER_COLORS.size());
    private Map<Color, JButton[]> baseFields = new HashMap<>(InitValue.COUNTER_COLORS.size());
    private ArrayList<JButton> fields = new ArrayList<>(40);
    
    // Idąc przez plansze zaczynajac od górnego środkowego punktu (0; 5) 
    // trzeba ,,skręcić" w odpowiednim kierunku. Lista kierunków, w jakich trzeba przejść, jest zapisana w tej tablicy.
    private char[] roadDirections = {'>', 'v', '>', 'v', '<', 'v', '<', '^', '<', '^', '>', '^'};
    // Tablica zawierająca ile buttonów trzeba wstawić do tablicy idąc w danym kierunku.
    private int[] howManyButtons = {2, 4, 4};
  
    private java.util.Timer timer = new java.util.Timer();
    private int eyesIterator = 0;
    
    /**
     * Creates new form GameFrameAPI
     */
    public GameFrameAPI() {
	initComponents();	
    }

   
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        pBoard = new javax.swing.JPanel();
        ePlayer1 = new javax.swing.JLabel();
        ePlayer2 = new javax.swing.JLabel();
        ePlayer3 = new javax.swing.JLabel();
        pLeftUpBase = new javax.swing.JPanel();
        pRightUpBase = new javax.swing.JPanel();
        pLeftDownBase = new javax.swing.JPanel();
        pRightDownBase = new javax.swing.JPanel();
        pFields = new javax.swing.JPanel();
        ePlayer4 = new javax.swing.JLabel();
        pOptions = new javax.swing.JPanel();
        bDie = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Chińczyk");

        pBoard.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED, new java.awt.Color(0, 0, 0), new java.awt.Color(0, 0, 0), java.awt.Color.black, java.awt.Color.black));

        ePlayer1.setText("Gracz1");

        ePlayer2.setText("Gracz2");

        ePlayer3.setText("Gracz3");

        javax.swing.GroupLayout pLeftUpBaseLayout = new javax.swing.GroupLayout(pLeftUpBase);
        pLeftUpBase.setLayout(pLeftUpBaseLayout);
        pLeftUpBaseLayout.setHorizontalGroup(
            pLeftUpBaseLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 102, Short.MAX_VALUE)
        );
        pLeftUpBaseLayout.setVerticalGroup(
            pLeftUpBaseLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 77, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout pRightUpBaseLayout = new javax.swing.GroupLayout(pRightUpBase);
        pRightUpBase.setLayout(pRightUpBaseLayout);
        pRightUpBaseLayout.setHorizontalGroup(
            pRightUpBaseLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        pRightUpBaseLayout.setVerticalGroup(
            pRightUpBaseLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 77, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout pLeftDownBaseLayout = new javax.swing.GroupLayout(pLeftDownBase);
        pLeftDownBase.setLayout(pLeftDownBaseLayout);
        pLeftDownBaseLayout.setHorizontalGroup(
            pLeftDownBaseLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 102, Short.MAX_VALUE)
        );
        pLeftDownBaseLayout.setVerticalGroup(
            pLeftDownBaseLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 97, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout pRightDownBaseLayout = new javax.swing.GroupLayout(pRightDownBase);
        pRightDownBase.setLayout(pRightDownBaseLayout);
        pRightDownBaseLayout.setHorizontalGroup(
            pRightDownBaseLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 102, Short.MAX_VALUE)
        );
        pRightDownBaseLayout.setVerticalGroup(
            pRightDownBaseLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 97, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout pFieldsLayout = new javax.swing.GroupLayout(pFields);
        pFields.setLayout(pFieldsLayout);
        pFieldsLayout.setHorizontalGroup(
            pFieldsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 706, Short.MAX_VALUE)
        );
        pFieldsLayout.setVerticalGroup(
            pFieldsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 233, Short.MAX_VALUE)
        );

        ePlayer4.setText("Gracz4");

        javax.swing.GroupLayout pBoardLayout = new javax.swing.GroupLayout(pBoard);
        pBoard.setLayout(pBoardLayout);
        pBoardLayout.setHorizontalGroup(
            pBoardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pBoardLayout.createSequentialGroup()
                .addGap(37, 37, 37)
                .addComponent(ePlayer1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(ePlayer2)
                .addGap(31, 31, 31))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pBoardLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(pBoardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(pLeftUpBase, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(pLeftDownBase, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(pBoardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(pRightUpBase, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(pRightDownBase, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
            .addGroup(pBoardLayout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(pFields, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(pBoardLayout.createSequentialGroup()
                .addGap(38, 38, 38)
                .addComponent(ePlayer4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(ePlayer3)
                .addGap(33, 33, 33))
        );
        pBoardLayout.setVerticalGroup(
            pBoardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pBoardLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(pBoardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(pLeftUpBase, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(pRightUpBase, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(pBoardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(ePlayer1)
                    .addComponent(ePlayer2))
                .addGap(2, 2, 2)
                .addComponent(pFields, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(pBoardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(ePlayer3)
                    .addComponent(ePlayer4))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(pBoardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(pRightDownBase, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(pLeftDownBase, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pOptions.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED, java.awt.Color.black, java.awt.Color.black, java.awt.Color.black, java.awt.Color.black));

        bDie.setText("Kostka");
        bDie.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                bDieActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout pOptionsLayout = new javax.swing.GroupLayout(pOptions);
        pOptions.setLayout(pOptionsLayout);
        pOptionsLayout.setHorizontalGroup(
            pOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pOptionsLayout.createSequentialGroup()
                .addGap(90, 90, 90)
                .addComponent(bDie)
                .addContainerGap(89, Short.MAX_VALUE))
        );
        pOptionsLayout.setVerticalGroup(
            pOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pOptionsLayout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addComponent(bDie, javax.swing.GroupLayout.DEFAULT_SIZE, 51, Short.MAX_VALUE)
                .addGap(27, 27, 27))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(pOptions, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(pBoard, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(pBoard, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGap(18, 18, 18)
                .addComponent(pOptions, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void bDieActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bDieActionPerformed
        
    }//GEN-LAST:event_bDieActionPerformed
    
    
    @Override
    public void viewGame(Board board, Player[] players) {
	this.setVisible(true);
	
	// Ustawianie etykiet graczy
	ePlayer1.setText(players[0].getName());
	ePlayer2.setText(players[1].getName());
	ePlayer3.setText(players[2].getName());
	ePlayer4.setText(players[3].getName());
	
	// Ustawianie pól startowych na ekranie
	baseFields.put(players[0].getColor(), createBasePanel(pLeftUpBase, players[0].getColor()));
	baseFields.put(players[1].getColor(), createBasePanel(pRightUpBase, players[1].getColor()));
	baseFields.put(players[2].getColor(), createBasePanel(pRightDownBase, players[2].getColor()));
	baseFields.put(players[3].getColor(), createBasePanel(pLeftDownBase, players[3].getColor()));
	
	setButtons(pFields, board, players);
	
	/*int i = 0;
	for(JButton b : fields){
	    b.setText("" + (i++));
	}*/
	
	pack();
    }
    
    @Override
    public void viewBoard(Board board, Player player) {	
	// Pokazanie pionków na ekranie
	viewCounters(board);
	
	bDie.setEnabled(player.ifUser());
	
	pack();
    }
    
    protected JButton[] createBasePanel(JPanel panel, Color baseColor){
	panel.setLayout(new GridLayout(2, 2, 6, 6));
	JButton[] buttons = new JButton[InitValue.COUNTER_COLORS.size() - 1];
	for(int i = 0; i < InitValue.COUNTER_COLORS.size() - 1; i++){
	    buttons[i] = new JButton(" ");
	    buttons[i].setBackground(baseColor);
	    buttons[i].setEnabled(false);
	    panel.add(buttons[i]);
	    // Dodać potem actionListener
	}
	return buttons;
    }
    
    protected void setButtons(JPanel pBoard, Board board, Player[] players){
	pFields.setLayout(new GridLayout(11, 11, 6, 6));
	
	JButton[][] allButtons = new JButton[11][11];
	
	// Iteratory, za pomocą których będą dodawane dane do tablicy JButton w mapie houseFields.
	// Trzeba dodawać je z dwóch różnych ,,kierunków" bo np. przy lewym domku wchodzi się od lewej
	// do prawej a z kolei w zielonym domku wchodzi się od prawej do lewej, stąd do tablicy
	// trzeba zapisać ostatni element domku na planszy jako pierwszy element tablicy.
	int direction = 0,
	    reverseDirection = 4;
	
        for(int i = 0; i < 11; i++){
            for(int j = 0; j < 11; j++){
                allButtons[i][j] = new JButton(" "); //"(" + i + ", " + j + ")"
                pBoard.add(allButtons[i][j]);
                if(i < 4 && j < 4 || i > 6 && j < 4 || i < 4 && j > 6 || i > 6 && j > 6 || i == 5 && j == 5)
                    allButtons[i][j].setVisible(false);
            }
        }
	
	setFields(allButtons, board, players);
    }
    
    /**
     * Wywoływana w <code>protected void setButtons(JPanel pBoard)</code>
     * Plansza musi być zrobiona za pomocą grida by wykorzystać tę funkcje.
     * Przy tworzeniu planszy trzeba zapisać wszystkie guziki jakie zostały
     * dodane do panelu. Następnie trzeba dodać w odpowiedniej kolejności
     * te guziki, które mają być w składzie pól na planszy.
     * @param gridOfButtons - Dwuwymiarowa tablica 
     */
    
    protected void setFields(JButton[][] gridOfButtons, Board board, Player[] players){
	// Col powinno być 5 ale najpierw w pętli jest ustawiany kierunek i zmieniana
	// wartość. Dlatego trzeba ustawić jedną kolumnę mniej by w pętli zwiększyło
	// na właściwą wartość
	int row = 0,
	    col = 4; 
	// Ustawia  tablicę zwykłych pól, po których poruszają się pionki.
	for(int i = 0; i < roadDirections.length; i++){
	    for(int j = 0; j < howManyButtons[i % 3]; j++){
		switch(roadDirections[i]){
		    case '^':
			row--;
			break;
			
		    case '>':
			col++;
			break;
			
		    case 'v':
			row++;
			break;
			
		    case '<':
			col--;
			break;
		}
		gridOfButtons[row][col].setEnabled(false);
		fields.add(gridOfButtons[row][col]);
	    }
	}
	
	
	
	for(int i = 0; i < players.length; i++){
	    fields.get(board.outFields[i]).setBackground(players[i].getColor());
	}
	// Ustawianie tablic, które zostaną dodane do mapy <code>houseFields</code>
	for(Color fieldColor : InitValue.COUNTER_COLORS.values()){
	    if(fieldColor != null){
		houseFields.put(fieldColor, new JButton[4]);
		
	    }
	}	    
	
	// Uzupełnianie tablicy guzików guzikami finiszu na planszy
	for(int i = 1; i < 5; i++){
	    houseFields.get(players[0].getColor())[i - 1] = gridOfButtons[5][i];
	    houseFields.get(players[1].getColor())[i - 1] = gridOfButtons[i][5];
	    houseFields.get(players[2].getColor())[i - 1] = gridOfButtons[5][10 - i];
	    houseFields.get(players[3].getColor())[i - 1] = gridOfButtons[10 - i][5];
	}
	
	// Ustawianie kolorów guzików finiszu
	for(Player player : players){
	    for(int i = 0; i < 4; i++){
		houseFields.get(player.getColor())[i].setBackground(player.getColor());
		houseFields.get(player.getColor())[i].setEnabled(false);
	    }
	}
	
    }
    
    @Override
    public void clearBoard(){
	for(JButton b : fields){
	    b.setText(" ");
	}
	
	for(Color color : baseFields.keySet())
	    for(JButton b : baseFields.get(color))
		b.setText(" ");
    }

    @Override
    public void viewWinner(Player player) {
	//JOptionPane.showMessageDialog(this, "Zwycięstwo!", );
	JOptionPane.showMessageDialog(this, "Gracz " + player.getName() + " wygrał tę partie.\nGratulacje!", "Zwycięsca!", JOptionPane.PLAIN_MESSAGE);
    }

    @Override
     public ArrayList<Counter> viewAvalibleCounters(Player player, int whichPlayer, int howManyEye, Board board){
	ArrayList<Counter> counters = new ArrayList<Counter>();
	// Tablica potrzebna by rozróżnić który pionek z bazy ma zostać aktywowany
	ArrayList<Integer> whichCounter = new ArrayList<Integer>();
	
	for(int i = 0; i < board.getBoard().get(player.getColor()).length; i++){
	    Counter counter = board.getBoard().get(player.getColor())[i];
	    int position = counter.getPosition();
	    
	    // Pionek znajduje się w bazie i gracz wyrzucił 6 (a więc może nim wyjść)
	    if(position == -1 && howManyEye == 6){
		counters.add(counter);
		whichCounter.add(i);
	    } // Pionek znajduje się tuż przed wejściem do domku i trzeba sprawdzić czy nie wejdzie
	      // na pionek, który się tam już znajduje
	    else if(counter.ifCloseToHouse(board.outFields[whichPlayer], howManyEye)){
		// Koliduje
		boolean collide = false;
		for(int j = 0; j < board.getBoard().get(player.getColor()).length; j++){		    
		    if(i != j && counter.getHousePosition(board.outFields[whichPlayer], howManyEye) == board.getBoard().get(player.getColor())[j].getPosition()){
			collide = true;
			break;
		    }
		}
		if(!collide)
		    counters.add(counter);
	    }else if(-1 < position && position < 40){
		// Jeśli więcej jak jeden pionek przeciwnika znajdują się na polu,
		// na które miałby wejść aktualny pionek to nie można go dodać do listy
		// aby został aktywny.
		boolean ifAdd = true;
		for(Color color : board.getBoard().keySet()){
		    if(color.equals(player.getColor()))
			continue;

		    if(board.countCountersOnField(color, counter.getPositionAfterJump(howManyEye)) > 1){
			System.out.println(board.countCountersOnField(color, position));
			ifAdd = false;
			break;
		    }

		}
		
		if(ifAdd)
		    counters.add(counter);
	    }
		
	}
	
	if(player.ifUser()){
	    for(int i = 0; i < counters.size(); i++){
		if(counters.get(i).getPosition() == -1){
		    baseFields.get(player.getColor())[whichCounter.get(0)].setEnabled(true);
		    whichCounter.remove(0);
		}else
		    fields.get(counters.get(i).getPosition()).setEnabled(true);
	    }
	}
	
	return counters;
    }
    
    @Override
    public void viewCounters(Board board) {	
	clearBoard();
	for(Color color : board.getBoard().keySet()){
	    for(int i = 0; i < board.getBoard().get(color).length; i++){
		Counter tmp = board.getCounter(color, i);
		if(tmp.getPosition() == -1){
		    baseFields.get(color)[i].setText("p");
		}
		else if(tmp.getPosition() > -1 && tmp.getPosition() < 40){
		    int howManyCounters = board.countCountersOnField(color, tmp.getPosition());
		    fields.get(tmp.getPosition()).setText(howManyCounters == 1 ? "p" : howManyCounters + "p");
		}
		    
		else{
		    houseFields.get(color)[tmp.getPosition() % 40].setText("p");
		}
		    
	    }
	}
    }

    @Override
    public void viewExitInfo() {
	JOptionPane.showMessageDialog(this, "Koniec gry");
    }

    @Override
    public void viewPlayerDraw(boolean ifUser) {
	bDie.setEnabled(ifUser);
    }
    
    @Override
    public int viewDieAnimation() {
	int draw = draw();
	ArrayList<Integer> draws = new ArrayList<Integer>(5);
	int viewDraw = 0;
	for(int i = 0; i < 4; i++){
	    do{
		viewDraw = draw();
	    }while(i != 0 && viewDraw == draws.get(i - 1));
	    draws.add(viewDraw);
	    bDie.setText(viewDraw + "");
	    try {
		Thread.sleep(1000);
	    } catch (InterruptedException ex) {
		ex.printStackTrace();
	    }
	}
	
	bDie.setText(draw + "");
	return draw;
    }

    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton bDie;
    private javax.swing.JLabel ePlayer1;
    private javax.swing.JLabel ePlayer2;
    private javax.swing.JLabel ePlayer3;
    private javax.swing.JLabel ePlayer4;
    private javax.swing.JPanel pBoard;
    private javax.swing.JPanel pFields;
    private javax.swing.JPanel pLeftDownBase;
    private javax.swing.JPanel pLeftUpBase;
    private javax.swing.JPanel pOptions;
    private javax.swing.JPanel pRightDownBase;
    private javax.swing.JPanel pRightUpBase;
    // End of variables declaration//GEN-END:variables

}
