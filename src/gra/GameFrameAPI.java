
package gra;

import static gra.GameFrame.RANDOM;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.*;
import javax.swing.*;
import javax.swing.plaf.metal.MetalButtonUI;

/**
 *
 * @author Komputer Domowy
 */
public class GameFrameAPI extends JFrame implements GameFrame, ActionListener {
    private GameEngine gameEngine;
    private Map<Color, JButton[]> houseFields = new HashMap<>(InitValue.COUNTER_COLORS.size());
    private Map<Color, JButton[]> baseFields = new HashMap<>(InitValue.COUNTER_COLORS.size());
    private ArrayList<JButton> fields = new ArrayList<>(40);
    private Map<Color, ImageIcon> counterIcons = new HashMap<>(InitValue.COUNTER_COLORS.size());
    
    private ArrayList<Counter> avalibleCounters;
    
    // Idąc przez plansze zaczynajac od górnego środkowego punktu (0; 5) 
    // trzeba ,,skręcić" w odpowiednim kierunku. Lista kierunków, w jakich trzeba przejść, jest zapisana w tej tablicy.
    private char[] roadDirections = {'>', 'v', '>', 'v', '<', 'v', '<', '^', '<', '^', '>', '^'};
    // Tablica zawierająca ile buttonów trzeba wstawić do tablicy idąc w danym kierunku.
    private int[] howManyButtons = {2, 4, 4};
  
    //private java.util.Timer timer = new java.util.Timer();
    //private int eyesIterator = 0;
    private int playerDraw;
    protected final int DEFAULT_BUTTON_SIZE = 20;
    
    /**
     * Ustawianie właściwości okna.
     * 
     * @param gameEngine obiekt, który wywołuje <code>GameFrameApi</code>
     */
    public GameFrameAPI(GameEngine gameEngine) {
	initComponents();
	// Ustawianie okna na środku ekranu
	int screenWidth = (int)Toolkit.getDefaultToolkit().getScreenSize().getWidth(),
	    screenHeight = (int)Toolkit.getDefaultToolkit().getScreenSize().getHeight();
	
	setSize(700, 720);
	
	setLocation((screenWidth - getWidth()) / 2, (screenHeight - getHeight()) / 2);
	
	this.gameEngine = gameEngine;
	bDie.addActionListener(this);
    }

   
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        pBoard = new javax.swing.JPanel();
        ePlayer1 = new javax.swing.JLabel();
        ePlayer2 = new javax.swing.JLabel();
        ePlayer3 = new javax.swing.JLabel();
        pLeftUpBase = new javax.swing.JPanel();
        pRightUpBase = new javax.swing.JPanel();
        pLeftDownBase = new javax.swing.JPanel();
        pRightDownBase = new javax.swing.JPanel();
        pFields = new javax.swing.JPanel();
        ePlayer4 = new javax.swing.JLabel();
        pOptions = new javax.swing.JPanel();
        bDie = new javax.swing.JButton();
        lWhichPlayerDraw = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Chińczyk");

        pBoard.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED, new java.awt.Color(0, 0, 0), new java.awt.Color(0, 0, 0), java.awt.Color.black, java.awt.Color.black));

        ePlayer1.setText("Gracz1");

        ePlayer2.setText("Gracz2");

        ePlayer3.setText("Gracz3");

        javax.swing.GroupLayout pLeftUpBaseLayout = new javax.swing.GroupLayout(pLeftUpBase);
        pLeftUpBase.setLayout(pLeftUpBaseLayout);
        pLeftUpBaseLayout.setHorizontalGroup(
            pLeftUpBaseLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 102, Short.MAX_VALUE)
        );
        pLeftUpBaseLayout.setVerticalGroup(
            pLeftUpBaseLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 77, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout pRightUpBaseLayout = new javax.swing.GroupLayout(pRightUpBase);
        pRightUpBase.setLayout(pRightUpBaseLayout);
        pRightUpBaseLayout.setHorizontalGroup(
            pRightUpBaseLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        pRightUpBaseLayout.setVerticalGroup(
            pRightUpBaseLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 77, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout pLeftDownBaseLayout = new javax.swing.GroupLayout(pLeftDownBase);
        pLeftDownBase.setLayout(pLeftDownBaseLayout);
        pLeftDownBaseLayout.setHorizontalGroup(
            pLeftDownBaseLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 102, Short.MAX_VALUE)
        );
        pLeftDownBaseLayout.setVerticalGroup(
            pLeftDownBaseLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 97, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout pRightDownBaseLayout = new javax.swing.GroupLayout(pRightDownBase);
        pRightDownBase.setLayout(pRightDownBaseLayout);
        pRightDownBaseLayout.setHorizontalGroup(
            pRightDownBaseLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 102, Short.MAX_VALUE)
        );
        pRightDownBaseLayout.setVerticalGroup(
            pRightDownBaseLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 97, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout pFieldsLayout = new javax.swing.GroupLayout(pFields);
        pFields.setLayout(pFieldsLayout);
        pFieldsLayout.setHorizontalGroup(
            pFieldsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 706, Short.MAX_VALUE)
        );
        pFieldsLayout.setVerticalGroup(
            pFieldsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 233, Short.MAX_VALUE)
        );

        ePlayer4.setText("Gracz4");

        javax.swing.GroupLayout pBoardLayout = new javax.swing.GroupLayout(pBoard);
        pBoard.setLayout(pBoardLayout);
        pBoardLayout.setHorizontalGroup(
            pBoardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pBoardLayout.createSequentialGroup()
                .addGap(37, 37, 37)
                .addComponent(ePlayer1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(ePlayer2)
                .addGap(31, 31, 31))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pBoardLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(pBoardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(pLeftUpBase, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(pLeftDownBase, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(pBoardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(pRightUpBase, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(pRightDownBase, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
            .addGroup(pBoardLayout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(pFields, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
            .addGroup(pBoardLayout.createSequentialGroup()
                .addGap(38, 38, 38)
                .addComponent(ePlayer4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(ePlayer3)
                .addGap(33, 33, 33))
        );
        pBoardLayout.setVerticalGroup(
            pBoardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(pBoardLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(pBoardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(pLeftUpBase, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(pRightUpBase, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(pBoardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(ePlayer1)
                    .addComponent(ePlayer2))
                .addGap(22, 22, 22)
                .addComponent(pFields, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(pBoardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(ePlayer3)
                    .addComponent(ePlayer4))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(pBoardLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(pRightDownBase, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(pLeftDownBase, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );

        pOptions.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED, java.awt.Color.black, java.awt.Color.black, java.awt.Color.black, java.awt.Color.black));

        bDie.setText("Kostka");

        lWhichPlayerDraw.setText("aktualny gracz:");

        javax.swing.GroupLayout pOptionsLayout = new javax.swing.GroupLayout(pOptions);
        pOptions.setLayout(pOptionsLayout);
        pOptionsLayout.setHorizontalGroup(
            pOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pOptionsLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(lWhichPlayerDraw)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 35, Short.MAX_VALUE)
                .addComponent(bDie)
                .addGap(98, 98, 98))
        );
        pOptionsLayout.setVerticalGroup(
            pOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, pOptionsLayout.createSequentialGroup()
                .addContainerGap(21, Short.MAX_VALUE)
                .addGroup(pOptionsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(lWhichPlayerDraw)
                    .addComponent(bDie))
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(pOptions, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(pBoard, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(pBoard, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(pOptions, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents
    
    /**
     * <pre>
     * Metoda pobiera ikony z plików w projekcie a następnie wstawia je do <code>counterIcons</code>.
     * Ikony te przydadzą się do wyświetlania na guzikach graficznej reprezentacji pionka
     * </pre>
     */
    public void initCounterIcons(){
	final String DEFAULT_PATH = "counter";
	final String FILE_TYPE = ".png";
	Map<String, String> colorsPath = new HashMap<>(InitValue.COUNTER_COLORS.size());
	
	colorsPath.put("Czerwony", DEFAULT_PATH + "Red" + FILE_TYPE);
	colorsPath.put("Niebieski", DEFAULT_PATH + "Blue" + FILE_TYPE);
	colorsPath.put("Żółty", DEFAULT_PATH + "Yellow" + FILE_TYPE);
	colorsPath.put("Zielony", DEFAULT_PATH + "Green" + FILE_TYPE);
	
	Image image = Toolkit.getDefaultToolkit().getImage(DEFAULT_PATH + FILE_TYPE).getScaledInstance(DEFAULT_BUTTON_SIZE, DEFAULT_BUTTON_SIZE,  java.awt.Image.SCALE_SMOOTH);
	// Ikona pionków znajdujących się w polu bazy (przed wyjściem na planszę).
	counterIcons.put(Color.GRAY, new ImageIcon(image));
	
	// Ikony kolorowych pionków, potrzebne do wyświetlania na planszy.
	for(String colorName : colorsPath.keySet()){
	    image = Toolkit.getDefaultToolkit().getImage(colorsPath.get(colorName)).getScaledInstance(DEFAULT_BUTTON_SIZE, DEFAULT_BUTTON_SIZE,  java.awt.Image.SCALE_SMOOTH);
	    counterIcons.put(InitValue.COUNTER_COLORS.get(colorName), new ImageIcon(image));
	}
	
    }
    
    @Override
    public void viewGame(Board board, Player[] players) {
	this.setVisible(true);
	
	// Ustawianie etykiet graczy
	ePlayer1.setText(players[0].getName());
	ePlayer2.setText(players[1].getName());
	ePlayer3.setText(players[2].getName());
	ePlayer4.setText(players[3].getName());
	
	// Ustawianie pól startowych na ekranie
	baseFields.put(players[0].getColor(), createBasePanel(pLeftUpBase, players[0].getColor()));
	baseFields.put(players[1].getColor(), createBasePanel(pRightUpBase, players[1].getColor()));
	baseFields.put(players[2].getColor(), createBasePanel(pRightDownBase, players[2].getColor()));
	baseFields.put(players[3].getColor(), createBasePanel(pLeftDownBase, players[3].getColor()));
	
	// Ustawienie pól planszy (fields) i domku (houseFields).
	setButtons(pFields, board, players);
	
	/*int i = 0;
	for(JButton b : fields){
	    b.setText("" + (i++));
	}*/	
	initCounterIcons();
    }
    
    @Override
    public void viewBoard(Board board, Player player) {	
	/*for(Color color : gameEngine.getPlayersColors()){
	    for(int i = 0; i < 4; i++){
		System.out.println(board.getCounter(color, i).getPosition());
	    }
	}
	System.out.println(gameEngine.getPlayersIterator());*/
	
	
	// Pokazanie pionków na ekranie
	viewCounters(board);
	
	bDie.setEnabled(player.ifUser());
	
	lWhichPlayerDraw.setText("Aktualnie rzuca:\n" + player.getName());
	
	if(player.ifUser())
	    return;
	
	
	int whichPlayer = gameEngine.getPlayersIterator();
	int drawBot = draw();
	
	bDie.setText(" ");
	
	avalibleCounters = viewAvalibleCounters(player, whichPlayer, drawBot, board);
	
	if(!avalibleCounters.isEmpty()){
	    Counter counterToMove = avalibleCounters.get(RANDOM.nextInt(avalibleCounters.size()));
	    counterToMove.moveCounter(board.outFields[whichPlayer], drawBot);

	    gameEngine.collide(player.getColor(), counterToMove.getPosition());
	}
	
	gameEngine.game(drawBot == 6 ? gameEngine.getPlayersIterator() : gameEngine.getNextPlayer());	
	    
    }
    
    /**
     * <pre>
     * Metoda pobiera panel, w którym mają pojawić się pola bazy (przed wyjściem na planszę)
     * oraz kolor tej bazy. Następnie ustawia listenery, kolor itp.
     * </pre>
     * 
     * @param panel miejsce gdzie pojawią się guziki reprezentujące pola bazy.
     * @param baseColor kolor jaki ma przyjąć pole.
     * 
     * @return tablicę guzików zapisanych w panelu aby mieć do nich bezpośrednie odwołanie w tablicy <code>baseFields</code>.
     */
    protected JButton[] createBasePanel(JPanel panel, Color baseColor){
	panel.setLayout(new GridLayout(2, 2, 6, 6));
	JButton[] buttons = new JButton[InitValue.COUNTER_COLORS.size() - 1];
	for(int i = 0; i < InitValue.COUNTER_COLORS.size() - 1; i++){
	    buttons[i] = new JButton(" ");
	    buttons[i].setBackground(baseColor);
	    buttons[i].setEnabled(false);
	    panel.add(buttons[i]);
	    buttons[i].addActionListener(new ClicableFieldsHandler((i + 1) * -1));
	}
	return buttons;
    }
    
    /**
     * <pre>
     * Metoda tworzy kwadratową siatkę guzików, która następnie zostaje przetworzona na planszę
     * do chińczyka w kształcie plusa. Następnie tablica ta zostaje wysłana do <code>setFields</code>
     * aby z tablicy tej wyodrębnić pola startowe, pola końcowe oraz zapisać pola do chodzenia
     * w talicy <code>fields</code> aby odwzorowywały prawidłowy kierunek przechodzenia po planszy.
     * </pre>
     * 
     * @param pBoard panel, w którym znajdują się guziki reprezentujące pola planszy.
     * @param board obiekt tablicy przechowujący położenia wszystkich guzików potrzebny w <code>setFields</code>.
     * @param players tablica graczy. Potrzebna w <code>setFields</code> do pokolorowania pól.
     */
    protected void setButtons(JPanel pBoard, Board board, Player[] players){
	pFields.setLayout(new GridLayout(11, 11, 6, 6));
	
	JButton[][] allButtons = new JButton[11][11];
	
        for(int i = 0; i < 11; i++){
            for(int j = 0; j < 11; j++){
                allButtons[i][j] = new JButton(" "); //"(" + i + ", " + j + ")"
                pBoard.add(allButtons[i][j]);
		// Warunek usuwający z tablicy 4 narożne kwadraty z głównego kwadratu aby otrzymać znak plusa.
                if(
		    // lewy górny kwadrat
		    i < 4 && j < 4 || 
		    // lewy dolny kwadrat
		    i > 6 && j < 4 || 
		    // prawy górny kwadrat
		    i < 4 && j > 6 || 
		    //  prawy dolny kwadrat
		    i > 6 && j > 6 || 
		    // sam środek plusa, nienależący do żadnego pola
		    i == 5 && j == 5
		)
                    allButtons[i][j].setVisible(false);
            }
        }
	
	setFields(allButtons, board, players);
    }
    
    /**
     * <pre>
     * Wywoływana w <code>protected void setButtons(JPanel pBoard)</code>
     * W tej metodzie zapisujemy pola planszy do <code>fields</code> 
     * ze wcześniej stworzonej siatki guzików(potrzebny <code>GridLayout</code>).
     * Pola te są dodawane w metodzie w odpowiedniej kolejności 
     * (idąc od jednego punktu po zewnętrznej stronie planszy).
     * </pre>
     * 
     * @param gridOfButtons Dwuwymiarowa tablica przechowująca guziki w kształcie .
     * @param board obiekt przechowujący położenia wszystkich pionków na planszy.
     * @param players potrzebna do pobrania kolorów aby pokolorować <code>houseFields</code>.
     */
    protected void setFields(JButton[][] gridOfButtons, Board board, Player[] players){
	// Col powinno być 5 ale najpierw w pętli jest ustawiany kierunek i zmieniana
	// wartość. Dlatego trzeba ustawić jedną kolumnę mniej by w pętli zwiększyło
	// na właściwą wartość
	int row = 0,
	    col = 4; 
	// Ustawia  tablicę zwykłych pól, po których poruszają się pionki.
	for(int i = 0; i < roadDirections.length; i++){
	    for(int j = 0; j < howManyButtons[i % 3]; j++){
		switch(roadDirections[i]){
		    case '^':
			row--;
			break;
			
		    case '>':
			col++;
			break;
			
		    case 'v':
			row++;
			break;
			
		    case '<':
			col--;
			break;
		}
		gridOfButtons[row][col].setEnabled(false);
		gridOfButtons[row][col].addActionListener(new ClicableFieldsHandler(fields.size()));
		gridOfButtons[row][col].setBackground(new Color(173, 173, 173));
		fields.add(gridOfButtons[row][col]);
	    }
	}
	
	
	
	// Ustawianie kolorów pojedynczych pól, na które będą wychodzić pionki z bazy.
	for(int i = 0; i < players.length; i++)
	    fields.get(board.outFields[i]).setBackground(players[i].getColor());
	
	// Ustawianie tablic, które zostaną dodane do mapy <code>houseFields</code>
	for(Color fieldColor : InitValue.COUNTER_COLORS.values()){
	    if(fieldColor != null){
		houseFields.put(fieldColor, new JButton[4]);
	    }
	}	    
	
	// Uzupełnianie tablicy guzików guzikami finiszu na planszy
	for(int i = 1; i < 5; i++){
	    houseFields.get(players[0].getColor())[i - 1] = gridOfButtons[5][i];
	    houseFields.get(players[1].getColor())[i - 1] = gridOfButtons[i][5];
	    houseFields.get(players[2].getColor())[i - 1] = gridOfButtons[5][10 - i];
	    houseFields.get(players[3].getColor())[i - 1] = gridOfButtons[10 - i][5];
	}
	
	// Ustawianie kolorów guzików finiszu
	for(Player player : players){
	    for(int i = 0; i < 4; i++){
		houseFields.get(player.getColor())[i].setBackground(player.getColor());
		houseFields.get(player.getColor())[i].setEnabled(false);
	    }
	}
	
    }
    
    @Override
    public void clearBoard(){
	// UWAGA!
	// Nie trzeba czyścić pól domku (pola końcowe), ponieważ tam nie wykonujemy żadnego ruchu
	// poza wpisaniem nowego pionka na to miejsce. Metoda ta przydaje się tylko do czyszczenia pól
	// gdy pionek opuści dane miejsce a takowa sytuacja nie zachodzi w tym przypadku.
	  
	
	// Czyszczenie pól planszy do poruszania się.
	for(JButton b : fields){
	    b.setText(" ");
	    b.setIcon(null);
	    b.setDisabledIcon(null);
	    b.setBorder(BorderFactory.createLineBorder(b.getBackground(), 4));
	    /*b.setUI(new MetalButtonUI() {
		protected Color getDisabledTextColor() {
		    return Color.GRAY;
		}
	    });*/
	    b.setEnabled(false);
	}
	
	// Czyszczenie pól bazy (przed wyjściem na plansze).
	for(Color color : baseFields.keySet())
	    for(JButton b : baseFields.get(color)){
		b.setText(" ");
		b.setIcon(null);
		b.setDisabledIcon(null);
		b.setEnabled(false);
		b.setBorder(BorderFactory.createLineBorder(b.getBackground(), 4));
	    }
		
    }

    @Override
    public void viewWinner(Player player) {
	JOptionPane.showMessageDialog(this, "Gracz " + player.getName() + " wygrał tę partie.\nGratulacje!", "Zwycięzca!", JOptionPane.PLAIN_MESSAGE);
	this.dispose();
	System.exit(0);
    }

    @Override
     public ArrayList<Counter> viewAvalibleCounters(Player player, int whichPlayer, int howManyEye, Board board){
	ArrayList<Counter> counters = new ArrayList<>();
	// Tablica potrzebna by rozróżnić który pionek z bazy ma zostać aktywowany
	ArrayList<Integer> whichCounter = new ArrayList<>();
	
	// Pętla wykona się tyle razy ile pionków ma gracz.
	for(int i = 0; i < board.getBoard().get(player.getColor()).length; i++){
	    Counter playerCounter = board.getBoard().get(player.getColor())[i];
	    int position = playerCounter.getPosition();
	    
	    // Pionek znajduje się w bazie i gracz wyrzucił 6 (a więc może nim wyjść)
	    if(position == -1 && howManyEye == 6){
		counters.add(playerCounter);
		whichCounter.add(i);
	    } // Pionek znajduje się tuż przed wejściem do domku i trzeba sprawdzić czy nie wejdzie
	      // na pionek, który się tam już znajduje
	    else if(playerCounter.getPosition() < 40 && playerCounter.ifCanEnterHouse(howManyEye)){
		// Koliduje
		boolean collide = false;
		for(int j = 0; j < board.getBoard().get(player.getColor()).length; j++){		    
		    if(i != j && playerCounter.getHousePosition(howManyEye) == board.getBoard().get(player.getColor())[j].getPosition()){
			collide = true;
			break;
		    }
		}
		if(!collide){
		    counters.add(playerCounter);
		}
		
	    }else if(-1 < position && playerCounter.ifBeforeHouse(howManyEye)){
		// Jeśli więcej jak jeden pionek przeciwnika znajdują się na polu,
		// na które miałby wejść aktualny pionek to nie można go dodać do listy
		// aby został aktywny.
		boolean ifAdd = true;
		for(Color color : board.getBoard().keySet()){
		    if(color.equals(player.getColor()))
			continue;

		    if(board.countCountersOnField(color, playerCounter.getPositionAfterJump(howManyEye)) > 1){
			//System.out.println(board.countCountersOnField(color, position));
			ifAdd = false;
			break;
		    }
		}
		if(ifAdd){
		    //System.out.println("pozycja pionka na planszy: " + counter.getPosition());
		    counters.add(playerCounter);
		}
	    }
	}
	
	// Jeśli gracz jest użytkownikiem a nie botem to trzeba ustawić pola planszy na aktywne aby gracz mógł je wykorzystać do wykonania ruchu.
	if(player.ifUser()){
	    for(int i = 0; i < counters.size(); i++){
		if(counters.get(i).getPosition() == -1){
		    baseFields.get(player.getColor())[whichCounter.get(0)].setEnabled(true);
		    baseFields.get(player.getColor())[whichCounter.get(0)].setBorder(BorderFactory.createLineBorder(Color.cyan, 4));
		    whichCounter.remove(0);
		}else{
		    fields.get(counters.get(i).getPosition()).setEnabled(true);
		    fields.get(counters.get(i).getPosition()).setBorder(BorderFactory.createLineBorder(Color.cyan, 4));
		}    
	    }
	}
	
	return counters;
    }
    
     /**
      * <pre>
      * Metoda służy do odświeżania pionków na planszy. Powinna być wykonywana po każdym ruchu
      * gracza.
      * 
      * UWAGA!
      * W przyszłości można ją zastąpić metodą, która będzie edytować tylko poprzednie miejsce,
      * na którym znajdował się pionek oraz nowe miejsce pionka. To samo w przypadku gdy ruch
      * pionka spowoduje zbicie innego pionka.
      * </pre>
      * 
      * @param board obiekt tablicy, który przechowuje pozycje wszystkich pionków na planszy.
      */
    @Override
    public void viewCounters(Board board) {	
	clearBoard();
	
	for(Color color : board.getBoard().keySet()){
	    for(int i = 0; i < board.getBoard().get(color).length; i++){
		Counter tmp = board.getCounter(color, i);
		// Wyświetlanie pionka w polu bazy (przed wyjściem na plansze)
		if(tmp.getPosition() == -1){
		    //baseFields.get(color)[i].setText("p");
		    baseFields.get(color)[i].setIcon(counterIcons.get(Color.GRAY));
		    baseFields.get(color)[i].setDisabledIcon(counterIcons.get(Color.GRAY));
		}
		// Wyświetlanie pionka na planszy
		else if(tmp.getPosition() > -1 && tmp.getPosition() < 40){
		    int howManyCounters = board.countCountersOnField(color, tmp.getPosition());
		    //fields.get(tmp.getPosition()).setText(howManyCounters == 1 ? "p" : howManyCounters + "p");
		    // Jeśli dwa pionki tego samego koloru stoją na polu to trzeba napisać ile ich jest.
		    fields.get(tmp.getPosition()).setText(howManyCounters == 1 ? " " : howManyCounters + "");
		    fields.get(tmp.getPosition()).setIcon(counterIcons.get(color));
		    fields.get(tmp.getPosition()).setDisabledIcon(counterIcons.get(color));
		    
		    /*if(!color.equals(fields.get(tmp.getPosition()).getBackground())){
			fields.get(tmp.getPosition()).setUI(new MetalButtonUI() {
			    protected Color getDisabledTextColor() {
				return color;
			    }
			});
		    }*/
		}
		// Wyświetlanie pionka w domku (pole końcowe).
		else{
		    //System.out.println(color + "\t" + tmp.getPosition());
		    //houseFields.get(color)[tmp.getPosition() % 40].setText("");
		    houseFields.get(color)[tmp.getPosition() % 40].setIcon(counterIcons.get(Color.GRAY));
		    houseFields.get(color)[tmp.getPosition() % 40].setDisabledIcon(counterIcons.get(Color.GRAY));
		}
		    
	    }
	}
    }

    @Override
    public void viewExitInfo() {
	JOptionPane.showMessageDialog(this, "Koniec gry");
    }
    
    @Override
    public int viewDieAnimation() {
	int draw = draw();
	ArrayList<Integer> draws = new ArrayList<>(5);
	int viewDraw = 0;
	for(int i = 0; i < 4; i++){
	    do{
		// Będzie losować do momentu aż poprzedni rzut będzie inny od aktualnego.
		viewDraw = draw();
	    }while(i != 0 && viewDraw == draws.get(i - 1));
	    draws.add(viewDraw);
	    bDie.setText(viewDraw + "");
	}
	
	bDie.setText(draw + "");
	return draw;
    }

    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton bDie;
    private javax.swing.JLabel ePlayer1;
    private javax.swing.JLabel ePlayer2;
    private javax.swing.JLabel ePlayer3;
    private javax.swing.JLabel ePlayer4;
    private javax.swing.JLabel lWhichPlayerDraw;
    private javax.swing.JPanel pBoard;
    private javax.swing.JPanel pFields;
    private javax.swing.JPanel pLeftDownBase;
    private javax.swing.JPanel pLeftUpBase;
    private javax.swing.JPanel pOptions;
    private javax.swing.JPanel pRightDownBase;
    private javax.swing.JPanel pRightUpBase;
    // End of variables declaration//GEN-END:variables
    
    /**
     * <pre>
     * Listener do kostki. Obsługuje tylko rzut gracza niebędącego botem. 
     * Jeśli gracz nie posiada pionków, którymi może wykonać ruch,
     * to gra toczy się dalej przechodząc do kolejnego gracza.
     * </pre>
     * @param e - przesyła obiekt, który wywołuje tę metodę (w tym przypadku tylko kostkę więc jest nieużywany)
     */
    @Override
    public void actionPerformed(ActionEvent e) {
	int whichPlayer = gameEngine.getPlayersIterator();
	playerDraw = draw();
	
	bDie.setText(playerDraw + "");
	bDie.setEnabled(false);
	    
	avalibleCounters = viewAvalibleCounters(gameEngine.getCurrentPlayer(), whichPlayer, playerDraw, gameEngine.getBoard());
	
	if(avalibleCounters.size() == 0){
	    gameEngine.game(gameEngine.getNextPlayer());
	    return;
	}
	
    }

    
    public class ClicableFieldsHandler implements ActionListener{
	/**
	 * <pre>
	 * Dla pól, po których się chodzi <code>fields</code> przyjmuje normalne wartości.
	 * Dla pól <code>baseFields</code> przyjmuje wartości [-1; -4], stąd by otrzymać pionek
	 * trzeba wyciągnąć wartość absolutną i odjąć 1 (otrzymamy wartości [0; 3]).
	 * </pre>
	 */
	private int positionOnBoard;
	
	public ClicableFieldsHandler(int positionOnBoard){
	    this.positionOnBoard = positionOnBoard;
	}
	
	/**
	 * <pre>
	 * Metoda zwracająca pionek kliknięty przez użytkownika. 
	 * Może zwrócić pionek znajdujący się w bazie jak i na polu planszy.
	 * </pre>
	 * 
	 * @return obiekt reprezentujący pionek znajdujący się na planszy lub nic. Przydatne przy przemieszczaniu pionka.
	 */
	public Counter getCounterToMove(){
	    if(positionOnBoard < 0){
		int whichCounter = Math.abs(positionOnBoard) - 1;
		Color playerColor = gameEngine.getCurrentPlayer().getColor();
		
		return gameEngine.getBoard().getCounter(playerColor, whichCounter);
	    }
	    
	    for(Counter counter : avalibleCounters){
		if(counter.getPosition() != positionOnBoard)
		    continue;
		
		return counter;
	    }
	    
	    return null;
	}
	
	/**
	 * <pre>
	 * Metoda odpowiadająca za obsługę klawiszy reprezentujące pola na planszy.
	 * Po kliknięciu na pole, pionek zmienia swoje położenie a następnie gra idzie do przodu.
	 * </pre>
	 * 
	 * @param e 
	 */
	@Override
	public void actionPerformed(ActionEvent e) {
	    
	    Counter counterToMove = getCounterToMove();
	    counterToMove.moveCounter(gameEngine.getBoard().outFields[gameEngine.getPlayersIterator()], playerDraw);
	    
	    gameEngine.collide(gameEngine.getCurrentPlayer().getColor(), counterToMove.getPosition());
	    gameEngine.game(playerDraw == 6 ? gameEngine.getPlayersIterator() : gameEngine.getNextPlayer());
	    
	}
	
    }
}
